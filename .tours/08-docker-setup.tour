{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "08. Docker & Containerization",
  "description": "Learn how Docker and Docker Compose containerize the application for consistent development and deployment.",
  "steps": [
    {
      "file": "docker-compose.yml",
      "line": 1,
      "title": "What is Docker?",
      "description": "## Introduction to Docker\n\n### The Problem Docker Solves:\n\nHave you ever said: \"But it works on MY computer!\"\n\nDifferent developers have:\n- Different operating systems (Windows, Mac, Linux)\n- Different software versions installed\n- Different configurations\n\nThis causes bugs that only happen on some machines!\n\n### What is Docker?\n\n**Docker** packages applications and their dependencies into **containers** - isolated environments that run the same everywhere.\n\n### Container vs Virtual Machine:\n\n| Feature | Virtual Machine | Docker Container |\n|---------|----------------|------------------|\n| Size | Gigabytes (full OS) | Megabytes (just app) |\n| Startup | Minutes | Seconds |\n| Resource usage | Heavy | Lightweight |\n| Isolation | Complete | Process-level |\n\n### Real-World Analogy:\n\n**Shipping containers** revolutionized global trade because:\n- Standard size fits any ship, train, or truck\n- Contents don't matter - the container is the same\n- Easy to stack and transport\n\nDocker containers work the same way for software!\n\n---\n\n## To Do: Set Up Docker\n\n### Prerequisites:\n1. **Install Docker Desktop** from [docker.com](https://www.docker.com/products/docker-desktop)\n2. Verify installation: `docker --version`\n3. Verify Docker Compose: `docker compose version`\n\n### Common Errors:\n| Error | Cause | Fix |\n|-------|-------|-----|\n| `docker: command not found` | Docker not installed | Install Docker Desktop |\n| `Cannot connect to Docker daemon` | Docker not running | Start Docker Desktop app |\n| `Permission denied` | User not in docker group | Run: `sudo usermod -aG docker $USER` |"
    },
    {
      "file": "Dockerfile",
      "line": 1,
      "title": "The Dockerfile - Building Container Images",
      "description": "## What is a Dockerfile?\n\nA **Dockerfile** is a recipe for creating a Docker image. It contains step-by-step instructions to build your application's environment.\n\n### Key Concepts:\n\n| Term | Meaning | Analogy |\n|------|---------|--------|\n| **Dockerfile** | Build instructions | Recipe |\n| **Image** | Built template | Frozen cake batter |\n| **Container** | Running instance | Baked cake |\n\n### Multi-Stage Builds:\n\nOur Dockerfile uses **multi-stage builds** for efficiency:\n\n```\nStage 1 (Builder)     Stage 2 (Production)\n┌─────────────────┐   ┌─────────────────┐\n│ Full Node.js    │   │ Slim Node.js    │\n│ All dependencies│   │ Prod deps only  │\n│ TypeScript      │ → │ Compiled JS     │\n│ Source code     │   │ No source code  │\n│ ~800MB          │   │ ~150MB          │\n└─────────────────┘   └─────────────────┘\n```\n\nThe final image is small and secure - no dev tools, no source code!\n\n---\n\n## To Do: Create Your Dockerfile\n\n### Step 1: Create the file\n```bash\ntouch Dockerfile\n```\n\n### Step 2: Add the content\n```dockerfile\n# Stage 1: Build\nFROM node:lts-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY tsconfig.json ./\nCOPY src ./src\nRUN npm run build\n\n# Stage 2: Production\nFROM node:lts-alpine AS production\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --omit=dev\nCOPY --from=builder /app/dist ./dist\nEXPOSE 2201\nCMD [\"node\", \"dist/server.js\"]\n```\n\n### Watch Out For:\n- Use `node:lts-alpine` (not just `node`) for smaller images\n- Copy `package*.json` first for better layer caching\n- Use `npm ci` (not `npm install`) for reproducible builds\n\n### Common Errors:\n| Error | Cause | Fix |\n|-------|-------|-----|\n| `COPY failed: file not found` | Wrong path | Check file exists, paths are relative to Dockerfile |\n| `npm ERR! missing script: build` | No build script | Add `\"build\": \"tsc\"` to package.json scripts |"
    },
    {
      "file": "Dockerfile",
      "line": 11,
      "title": "Understanding Dockerfile Commands",
      "description": "## Dockerfile Instructions Explained\n\n### FROM - Base Image\n```dockerfile\nFROM node:lts-alpine AS builder\n```\n- `FROM` - Start from an existing image\n- `node:lts-alpine` - Node.js LTS on Alpine Linux (tiny!)\n- `AS builder` - Name this stage for later reference\n\n### WORKDIR - Working Directory\n```dockerfile\nWORKDIR /app\n```\nSets the directory for subsequent commands. Creates it if it doesn't exist.\n\n### COPY - Copy Files\n```dockerfile\nCOPY package*.json ./\nCOPY --from=builder /app/dist ./dist\n```\n- Copy from host to container\n- `--from=builder` copies from another stage\n\n### RUN - Execute Commands\n```dockerfile\nRUN npm ci\nRUN npm run build\n```\nRuns commands during image build (not container runtime).\n\n### EXPOSE - Document Ports\n```dockerfile\nEXPOSE 2201\n```\nDocumentation only - tells developers what port the app uses.\n\n### CMD - Default Command\n```dockerfile\nCMD [\"node\", \"dist/server.js\"]\n```\nWhat runs when the container starts.\n\n---\n\n## To Do: Understand Layer Caching\n\n### Why Order Matters:\n\nDocker caches each layer. If a layer changes, all subsequent layers rebuild.\n\n**Good order (faster rebuilds):**\n```dockerfile\nCOPY package*.json ./     # Rarely changes\nRUN npm ci                 # Only reruns if package.json changes\nCOPY src ./src             # Changes often, but npm ci is cached!\n```\n\n**Bad order (slow rebuilds):**\n```dockerfile\nCOPY . .                   # Copies everything\nRUN npm ci                 # Reruns on ANY file change!\n```\n\n### Test It:\n1. Build image: `docker build -t my-app .`\n2. Change a source file\n3. Rebuild: `docker build -t my-app .`\n4. Notice \"Using cache\" for package installation!"
    },
    {
      "file": ".dockerignore",
      "line": 1,
      "title": "The .dockerignore File",
      "description": "## Excluding Files from Docker Build\n\n### What is .dockerignore?\n\nLike `.gitignore` for Git, `.dockerignore` tells Docker what files to skip when copying to the image.\n\n### Why It Matters:\n\n**Without .dockerignore:**\n```\nSending build context to Docker daemon  500MB\n```\n\n**With .dockerignore:**\n```\nSending build context to Docker daemon  350KB\n```\n\n### What to Exclude:\n\n| Exclude | Why |\n|---------|-----|\n| `node_modules` | Installed in container |\n| `dist` | Built in container |\n| `.env` | Contains secrets! |\n| `.git` | Huge, not needed |\n| `*.md` | Documentation |\n| `tests` | Not needed in production |\n\n---\n\n## To Do: Create .dockerignore\n\n### Step 1: Create the file\n```bash\ntouch .dockerignore\n```\n\n### Step 2: Add exclusions\n```\nnode_modules\ndist\n.env\n.env.local\n.git\n*.md\n.tours\ntests\n.idea\n.vscode\nDockerfile\ndocker-compose*.yml\n.dockerignore\n```\n\n### Watch Out For:\n- Never include `.env` in images (secrets leak!)\n- Exclude `node_modules` even if copying `package.json` first\n- Include the Dockerfile itself to prevent confusion\n\n### Verify It Works:\n```bash\n# Check what Docker sees\ndocker build --no-cache -t test . 2>&1 | grep \"Sending build context\"\n# Should be small (< 1MB for source code)\n```"
    },
    {
      "file": "docker-compose.yml",
      "line": 1,
      "title": "Docker Compose - Multi-Container Apps",
      "description": "## What is Docker Compose?\n\n### Docker vs Docker Compose:\n\n| Tool | Purpose | Use Case |\n|------|---------|----------|\n| Docker | Run single containers | `docker run mongo` |\n| Docker Compose | Run multiple containers | App + Database together |\n\n### Why Docker Compose?\n\nReal applications need multiple services:\n- API server (Node.js)\n- Database (MongoDB)\n- Cache (Redis) - future\n- Message queue (RabbitMQ) - future\n\nDocker Compose lets you:\n1. Define all services in ONE file\n2. Start everything with ONE command\n3. Configure networking between services\n4. Manage data persistence\n\n### Our Architecture:\n\n```\n┌─────────────────────────────────────────┐\n│           Docker Compose                │\n│  ┌─────────────────────────────────┐    │\n│  │      backend-network            │    │\n│  │                                 │    │\n│  │  ┌─────────┐    ┌───────────┐   │    │\n│  │  │ Backend │────│  MongoDB  │   │    │\n│  │  │ :2201   │    │  :27017   │   │    │\n│  │  └─────────┘    └───────────┘   │    │\n│  │                                 │    │\n│  └─────────────────────────────────┘    │\n└─────────────────────────────────────────┘\n         ↑                    ↑\n    localhost:2201       localhost:27017\n```\n\n---\n\n## To Do: Create docker-compose.yml\n\n### Basic Commands:\n```bash\n# Start all services\ndocker compose up -d\n\n# View running services\ndocker compose ps\n\n# View logs\ndocker compose logs -f\n\n# Stop all services\ndocker compose down\n\n# Stop and remove volumes (fresh start)\ndocker compose down -v\n```\n\n### Common Errors:\n| Error | Cause | Fix |\n|-------|-------|-----|\n| `port is already allocated` | Port in use | Stop other services or change port |\n| `network not found` | Network deleted | Run `docker compose down` then `up` |\n| `image not found` | Not built | Run `docker compose build` first |"
    },
    {
      "file": "docker-compose.yml",
      "line": 2,
      "title": "MongoDB Service Configuration",
      "description": "## Defining the MongoDB Service\n\n```yaml\nservices:\n  mongodb:\n    image: mongodb/mongodb-community-server\n    container_name: jharkhand-tourism-mongodb\n    restart: unless-stopped\n```\n\n### Key Properties:\n\n| Property | Value | Purpose |\n|----------|-------|--------|\n| `image` | mongodb/mongodb-community-server | Official MongoDB image |\n| `container_name` | jharkhand-tourism-mongodb | Easy to identify |\n| `restart` | unless-stopped | Auto-restart on crashes |\n\n### Environment Variables:\n\n```yaml\nenvironment:\n  MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME}\n  MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}\n  MONGO_INITDB_DATABASE: ${MONGO_DATABASE}\n  MONGO_APP_USER: ${MONGO_APP_USER}\n  MONGO_APP_PASSWORD: ${MONGO_APP_PASSWORD}\n```\n\n**All values come from `.env` file - no hardcoded secrets!**\n\n---\n\n## To Do: Configure MongoDB Service\n\n### Step 1: Add to .env file\n```env\n# MongoDB root credentials\nMONGO_ROOT_USERNAME=admin\nMONGO_ROOT_PASSWORD=your-secure-password\nMONGO_DATABASE=sih-2025-jharkhand-tourism\n\n# Application database user\nMONGO_APP_USER=app_user\nMONGO_APP_PASSWORD=your-app-password\n```\n\n### Step 2: Update .env.example\nAdd the same variables with placeholder values for other developers.\n\n### Watch Out For:\n- Use `${VAR}` syntax (not `$VAR`) for env variables in YAML\n- Don't use default values for secrets (e.g., `${VAR:-default}`)\n- Never commit `.env` to git!\n\n### Security Best Practice:\nGenerate secure passwords:\n```bash\nopenssl rand -base64 32\n```"
    },
    {
      "file": "docker-compose.yml",
      "line": 17,
      "title": "Volumes and Data Persistence",
      "description": "## Keeping Your Data Safe\n\n```yaml\nvolumes:\n  - mongodb_data:/data/db\n  - ./docker/mongo-init.sh:/docker-entrypoint-initdb.d/mongo-init.sh:ro\n```\n\n### The Problem Without Volumes:\n\nContainers are **ephemeral** (temporary). When you stop a container:\n- All data inside is LOST\n- Next start = empty database\n\n### Two Types of Mounts:\n\n**1. Named Volume (Docker-managed):**\n```yaml\nmongodb_data:/data/db\n```\n- `mongodb_data` - Docker manages this storage\n- `/data/db` - Path inside container where MongoDB stores data\n- Data survives container deletion\n\n**2. Bind Mount (your files):**\n```yaml\n./docker/mongo-init.sh:/docker-entrypoint-initdb.d/mongo-init.sh:ro\n```\n- `./docker/mongo-init.sh` - File on YOUR computer\n- `/docker-entrypoint-initdb.d/` - MongoDB runs scripts here on first start\n- `:ro` - Read-only (container can't modify it)\n\n---\n\n## To Do: Create Initialization Script\n\n### Step 1: Create docker directory\n```bash\nmkdir -p docker\n```\n\n### Step 2: Create mongo-init.sh\n```bash\ntouch docker/mongo-init.sh\nchmod +x docker/mongo-init.sh\n```\n\n### Step 3: Add initialization content\n```bash\n#!/bin/bash\nmongosh <<EOF\ndb = db.getSiblingDB('$MONGO_DATABASE');\ndb.createUser({\n    user: '$MONGO_APP_USER',\n    pwd: '$MONGO_APP_PASSWORD',\n    roles: [{ role: 'readWrite', db: '$MONGO_DATABASE' }]\n});\nprint('MongoDB initialization completed');\nEOF\n```\n\n### Watch Out For:\n- Script must be executable (`chmod +x`)\n- Use shell script (`.sh`) not JavaScript (`.js`) for env var substitution\n- Script only runs on FIRST container start (empty volume)"
    },
    {
      "file": "docker-compose.yml",
      "line": 22,
      "title": "Health Checks - Ensuring Services Are Ready",
      "description": "## Monitoring Container Health\n\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"mongosh\", \"--eval\", \"db.adminCommand('ping')\"]\n  interval: 10s\n  timeout: 5s\n  retries: 5\n  start_period: 30s\n```\n\n### What is a Health Check?\n\nA **health check** is a command that runs periodically to verify the service is working properly.\n\n### Health Check Options:\n\n| Option | Meaning | Our Value |\n|--------|---------|----------|\n| `interval` | How often to check | Every 10 seconds |\n| `timeout` | Max wait for response | 5 seconds |\n| `retries` | Failures before unhealthy | 5 times |\n| `start_period` | Grace period after startup | 30 seconds |\n\n### Container Health States:\n\n| State | Meaning |\n|-------|--------|\n| `starting` | Container just started, in grace period |\n| `healthy` | Health checks passing |\n| `unhealthy` | Health checks failing |\n\n---\n\n## To Do: Add Health Checks\n\n### For MongoDB:\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"mongosh\", \"--eval\", \"db.adminCommand('ping')\"]\n  interval: 10s\n  timeout: 5s\n  retries: 5\n  start_period: 30s\n```\n\n### For Backend:\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"wget\", \"-q\", \"--spider\", \"http://localhost:2201/api/v1/health\"]\n  interval: 30s\n  timeout: 10s\n  retries: 3\n  start_period: 40s\n```\n\n### Check Health Status:\n```bash\ndocker compose ps\n# Look for (healthy) or (unhealthy) in STATUS column\n\n# Detailed health info\ndocker inspect --format='{{json .State.Health}}' jharkhand-tourism-backend\n```\n\n### Common Errors:\n| Error | Cause | Fix |\n|-------|-------|-----|\n| Always unhealthy | Health check command wrong | Test command manually in container |\n| Unhealthy during start | start_period too short | Increase start_period |"
    },
    {
      "file": "docker-compose.yml",
      "line": 29,
      "title": "Backend Service Configuration",
      "description": "## The Node.js Backend Service\n\n```yaml\nbackend:\n  build:\n    context: .\n    dockerfile: Dockerfile\n  container_name: jharkhand-tourism-backend\n  restart: unless-stopped\n```\n\n### Build Configuration:\n\n| Property | Value | Meaning |\n|----------|-------|--------|\n| `build.context` | `.` | Build from current directory |\n| `build.dockerfile` | `Dockerfile` | Use this file for instructions |\n\n### Environment Variables:\n\n```yaml\nenvironment:\n  NODE_ENV: ${NODE_ENV:-production}\n  PORT: ${PORT:-2201}\n  MONGO_URI: mongodb://${MONGO_APP_USER}:${MONGO_APP_PASSWORD}@mongodb:27017/${MONGO_DATABASE}?authSource=${MONGO_DATABASE}\n  JWT_SECRET: ${JWT_SECRET}\n```\n\n**Note:** The hostname is `mongodb` (service name), not `localhost`!\n\n---\n\n## To Do: Configure Backend Service\n\n### Step 1: Add backend service to docker-compose.yml\n```yaml\nbackend:\n  build:\n    context: .\n    dockerfile: Dockerfile\n  container_name: jharkhand-tourism-backend\n  restart: unless-stopped\n  ports:\n    - \"${PORT:-2201}:${PORT:-2201}\"\n  environment:\n    NODE_ENV: ${NODE_ENV:-production}\n    PORT: ${PORT:-2201}\n    TZ: ${TZ:-Asia/Kolkata}\n    MONGO_URI: mongodb://${MONGO_APP_USER}:${MONGO_APP_PASSWORD}@mongodb:27017/${MONGO_DATABASE}?authSource=${MONGO_DATABASE}\n    JWT_SECRET: ${JWT_SECRET}\n    JWT_EXPIRES_IN: ${JWT_EXPIRES_IN:-7d}\n    BCRYPT_SALT_ROUNDS: ${BCRYPT_SALT_ROUNDS:-12}\n  depends_on:\n    mongodb:\n      condition: service_healthy\n  networks:\n    - backend-network\n```\n\n### Step 2: Update .env with all required variables\n```env\nJWT_SECRET=your-super-secret-jwt-key-min-32-chars\n```\n\n### Watch Out For:\n- Use service name (`mongodb`) not `localhost` in MONGO_URI\n- `depends_on: condition: service_healthy` waits for MongoDB\n- Both services must be on the same network"
    },
    {
      "file": "docker-compose.yml",
      "line": 45,
      "title": "Service Dependencies and Networking",
      "description": "## Controlling Startup Order\n\n```yaml\ndepends_on:\n  mongodb:\n    condition: service_healthy\n```\n\n### Why Dependencies Matter:\n\nWithout `depends_on`:\n1. Backend starts immediately\n2. Tries to connect to MongoDB\n3. MongoDB isn't ready yet\n4. **Connection fails!**\n\nWith `depends_on: service_healthy`:\n1. MongoDB starts\n2. Docker waits for health check to pass\n3. THEN backend starts\n4. **Connection succeeds!**\n\n### Docker Networks:\n\n```yaml\nnetworks:\n  backend-network:\n    driver: bridge\n```\n\nContainers on the same network can:\n- Communicate using service names as hostnames\n- Access each other's ports without exposing them\n\n```\nBackend → mongodb:27017 → MongoDB\n        (internal network, no port exposure needed)\n```\n\n---\n\n## To Do: Configure Networks\n\n### Step 1: Define network in docker-compose.yml\n```yaml\nnetworks:\n  backend-network:\n    driver: bridge\n```\n\n### Step 2: Add both services to the network\n```yaml\nservices:\n  mongodb:\n    networks:\n      - backend-network\n  \n  backend:\n    networks:\n      - backend-network\n```\n\n### Step 3: Update connection strings\nChange `localhost` to service name:\n```\n# Before (won't work in Docker)\nMONGO_URI=mongodb://user:pass@localhost:27017/db\n\n# After (works in Docker)\nMONGO_URI=mongodb://user:pass@mongodb:27017/db\n```\n\n### Verify Networking:\n```bash\n# Start services\ndocker compose up -d\n\n# Test connection from backend to mongodb\ndocker compose exec backend sh -c \"wget -qO- mongodb:27017 || echo 'MongoDB port reachable'\"\n```"
    },
    {
      "file": ".env.example",
      "line": 20,
      "title": "Environment Variables for Docker",
      "description": "## Complete Environment Configuration\n\n### Required Variables:\n\n```env\n# Server\nPORT=2201\nNODE_ENV=development\nTZ=Asia/Kolkata\n\n# MongoDB Root (for admin access)\nMONGO_ROOT_USERNAME=admin\nMONGO_ROOT_PASSWORD=secure-root-password\nMONGO_DATABASE=sih-2025-jharkhand-tourism\nMONGO_PORT=27017\n\n# MongoDB App User (for application)\nMONGO_APP_USER=app_user\nMONGO_APP_PASSWORD=secure-app-password\n\n# JWT\nJWT_SECRET=your-32-char-minimum-secret-key\nJWT_EXPIRES_IN=7d\n\n# Security\nBCRYPT_SALT_ROUNDS=12\n```\n\n### Why Two MongoDB Users?\n\n| User | Purpose | Permissions |\n|------|---------|------------|\n| Root | Database administration | Everything |\n| App User | Application access | Read/Write on one DB |\n\n**Principle of Least Privilege:** The app only gets what it needs!\n\n---\n\n## To Do: Set Up Environment Files\n\n### Step 1: Update .env.example\nAdd all Docker-related variables with placeholder values.\n\n### Step 2: Create .env from example\n```bash\ncp .env.example .env\n```\n\n### Step 3: Edit .env with real values\n```bash\n# Generate secure passwords\nopenssl rand -base64 32  # For MONGO_ROOT_PASSWORD\nopenssl rand -base64 32  # For MONGO_APP_PASSWORD\nopenssl rand -base64 32  # For JWT_SECRET\n```\n\n### Step 4: Verify .env is in .gitignore\n```bash\ngrep \".env\" .gitignore\n# Should show: .env\n```\n\n### Watch Out For:\n- Never use example passwords in production\n- JWT_SECRET must be at least 32 characters\n- Don't commit .env to version control"
    },
    {
      "file": "docker-compose.yml",
      "line": 1,
      "title": "Running the Containerized Application",
      "description": "## Complete Docker Workflow\n\n### Starting the Application:\n\n```bash\n# Build and start all services\ndocker compose up -d --build\n\n# Check status\ndocker compose ps\n\n# View logs\ndocker compose logs -f\n```\n\n### Testing the Application:\n\n```bash\n# Health check\ncurl http://localhost:2201/api/v1/health\n\n# Register a user\ncurl -X POST http://localhost:2201/api/v1/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"test@example.com\",\"password\":\"Password123\",\"name\":\"Test User\"}'\n```\n\n### Stopping the Application:\n\n```bash\n# Stop services (keep data)\ndocker compose down\n\n# Stop and remove all data (fresh start)\ndocker compose down -v\n```\n\n### Rebuilding After Code Changes:\n\n```bash\n# Rebuild and restart\ndocker compose up -d --build\n```\n\n---\n\n## To Do: Verify Your Setup\n\n### Complete Checklist:\n\n- [ ] Dockerfile created and tested\n- [ ] .dockerignore created\n- [ ] docker-compose.yml configured\n- [ ] docker/mongo-init.sh created and executable\n- [ ] .env created from .env.example\n- [ ] All environment variables set\n\n### Test Commands:\n```bash\n# 1. Build images\ndocker compose build\n\n# 2. Start services\ndocker compose up -d\n\n# 3. Wait for healthy status\ndocker compose ps\n# Both should show (healthy)\n\n# 4. Test health endpoint\ncurl http://localhost:2201/api/v1/health\n# Should return: {\"success\":true,...}\n\n# 5. Test database connection (register user)\ncurl -X POST http://localhost:2201/api/v1/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"docker-test@example.com\",\"password\":\"TestPass123\",\"name\":\"Docker Test\"}'\n```\n\n### Troubleshooting:\n\n| Problem | Command | Solution |\n|---------|---------|----------|\n| Container not starting | `docker compose logs backend` | Check error messages |\n| Can't connect to MongoDB | `docker compose logs mongodb` | Check MongoDB is healthy |\n| Port already in use | `lsof -i :2201` | Stop conflicting process |\n| Old code running | `docker compose up -d --build` | Force rebuild |\n\n---\n\n## Tour Complete!\n\nYou now understand Docker containerization! Your application can run consistently on any machine with Docker installed.\n\n### Key Files Created:\n- `Dockerfile` - Build instructions\n- `.dockerignore` - Excluded files\n- `docker-compose.yml` - Multi-container setup\n- `docker/mongo-init.sh` - Database initialization"
    }
  ]
}
